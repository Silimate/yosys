log -header "Should be turned into a tree"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a,
  input wire b,
  input wire c,
  input wire d,
  output wire x,
);
  assign x = a & b & c & d;
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt

# Checks if inputs to and gates has been rewired
select -set a_wires i:a %co
select -set driven_by_a @a_wires %co
select -set and_a_cell t:$and @driven_by_a %i

select -set b_wires i:b %co
select -set driven_by_b @b_wires %co
select -set and_b_cell t:$and @driven_by_b %i

select -assert-none @and_a_cell @and_b_cell %d

select -set c_wires i:c %co
select -set driven_by_c @c_wires %co
select -set and_c_cell t:$and @driven_by_c %i

select -set d_wires i:d %co
select -set driven_by_d @d_wires %co
select -set and_d_cell t:$and @driven_by_d %i

select -assert-none @and_c_cell @and_d_cell %d

design -reset
log -pop

log -header "Should not be turned into a tree"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a,
  input wire b,
  input wire c,
  input wire d,
  output wire x,
  output wire y,
  output wire z
);
  assign x = a & b;
  assign y = x & c;
  assign z = y & d;
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt

# Checks if y is still wired up to the correct gate
select -set y_wires o:y %ci
select -set y_driver @y_wires %ci
select -set and_y_cell t:$and @y_driver %i
select @and_y_cell -assert-count 1
select -set inputs @and_y_cell %ci
select -assert-count 1 @inputs i:c %i

design -reset
log -pop

log -header "With a cell"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a,
  input wire b,
  input wire c,
  input wire d,
  output wire x,
  output wire y,
  output wire z
);
  wire temp;
  assign y = ~temp;
  assign x = a & b;
  assign temp = x & c;
  assign z = temp & d;
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt
select -assert-count 3 t:$and

design -reset
log -pop

log -header "Word out port"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a,
  input wire b,
  input wire c,
  input wire d,
  output wire [2:0] x
);
  assign x[0] = a & b;
  assign x[1] = x[0] & c;
  assign x[2] = x[1] & d;
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt
select -assert-count 3 t:$and

design -reset
log -pop

log -header "Fanout going to multiple outputs"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a,
  input wire b,
  input wire c,
  input wire d,
  output wire [2:0] x,
  output wire y
);
  assign x[0] = a & b;
  assign x[1] = x[0] & c;
  assign x[2] = x[1] & d;

  assign y = x[1];
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt
select -assert-count 3 t:$and

design -reset
log -pop

log -header "Fanout going to multiple of the same word"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a,
  input wire b,
  input wire c,
  input wire d,
  output wire [3:0] x
);
  assign x[0] = a & b;
  assign x[1] = x[0] & c;
  assign x[2] = x[1] & d;
  assign x[3] = x[1];
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt
select -assert-count 3 t:$and

design -reset
log -pop

log -header "Interesting tree situation"
log -push
design -reset
read_verilog <<EOF
module top (
  input wire a, b, c, d,
  input wire e, f, g, h,
  output wire x,
);
  wire i, j;

  assign i = a & b & c & d;
  assign j = e & f & g & h & i;

  assign x = i & j;
endmodule
EOF
check -assert

# Check equivalence after opt_balance_tree
equiv_opt -assert opt_balance_tree

design -load postopt

# Checks if inputs to and gates has been rewired

# a and b
select -set a_wires i:a %co
select -set driven_by_a @a_wires %co
select -set and_a_cell t:$and @driven_by_a %i

select -set b_wires i:b %co
select -set driven_by_b @b_wires %co
select -set and_b_cell t:$and @driven_by_b %i

select -assert-none @and_a_cell @and_b_cell %d

# c and d
select -set c_wires i:c %co
select -set driven_by_c @c_wires %co
select -set and_c_cell t:$and @driven_by_c %i

select -set d_wires i:d %co
select -set driven_by_d @d_wires %co
select -set and_d_cell t:$and @driven_by_d %i

select -assert-none @and_c_cell @and_d_cell %d

# e and f
select -set e_wires i:e %co
select -set driven_by_e @e_wires %co
select -set and_e_cell t:$and @driven_by_e %i

select -set f_wires i:f %co
select -set driven_by_f @f_wires %co
select -set and_f_cell t:$and @driven_by_f %i

select -assert-none @and_e_cell @and_f_cell %d

# g and h
select -set g_wires i:g %co
select -set driven_by_g @g_wires %co
select -set and_g_cell t:$and @driven_by_g %i

select -set h_wires i:h %co
select -set driven_by_h @h_wires %co
select -set and_h_cell t:$and @driven_by_h %i

select -assert-none @and_g_cell @and_h_cell %d

design -reset
log -pop